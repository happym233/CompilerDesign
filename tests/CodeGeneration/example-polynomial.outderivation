stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class 
rule: 
<START>: [EPSILON: epsilon] <multiClassDeclOrFuncDef> [CREATE_NODE: program] 
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class 
rule: 
matching: class [class, class, 49]
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 49]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
rule: 
<optClassDecl2>: 
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
rule: 
matching: opencubr [opencubr, {, 49]
semantic stack: 
[epsilon][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public 
rule: 
matching: public [public, public, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id function 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function 
rule: 
<memberFuncDecl>: function id [CREATE_LEAF: id] colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: memberFuncDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function 
rule: 
matching: function [function, function, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate 
rule: 
matching: id [id, evaluate, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : 
rule: 
matching: colon [colon, :, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( 
rule: 
matching: openpar [openpar, (, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x 
rule: 
matching: id [id, x, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : 
rule: 
matching: colon [colon, :, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float 
rule: 
matching: float [float, float, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) 
rule: 
matching: closepar [closepar, ), 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float 
rule: 
matching: float [float, float, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
rule: 
matching: semi [semi, ;, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
matching: closecubr [closecubr, }, 51]
semantic stack: 
[epsilon][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
rule: 
matching: semi [semi, ;, 51]
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
matching: class [class, class, 53]
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR 
rule: 
matching: id [id, LINEAR, 53]
semantic stack: 
[epsilon][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id isa 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa 
rule: 
<optClassDecl2>: isa id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa 
rule: 
matching: isa [isa, isa, 53]
semantic stack: 
[epsilon][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 53]
semantic stack: 
[epsilon][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
rule: 
<multiCommaId>: 
semantic stack: 
[epsilon][class][epsilon][id][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
rule: 
matching: opencubr [opencubr, {, 53]
semantic stack: 
[epsilon][class][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private 
rule: 
matching: private [private, private, 54]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute 
rule: 
matching: attribute [attribute, attribute, 54]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a 
rule: 
matching: id [id, a, 54]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : 
rule: 
matching: colon [colon, :, 54]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float 
rule: 
matching: float [float, float, 54]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
matching: semi [semi, ;, 54]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
matching: private [private, private, 55]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
matching: attribute [attribute, attribute, 55]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b 
rule: 
matching: id [id, b, 55]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : 
rule: 
matching: colon [colon, :, 55]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
matching: float [float, float, 55]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
matching: semi [semi, ;, 55]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public 
rule: 
matching: public [public, public, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon constructor 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor 
rule: 
<memberFuncDecl>: constructor colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: memberConstructorDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor 
rule: 
matching: constructor [constructor, constructor, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : 
rule: 
matching: colon [colon, :, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( 
rule: 
matching: openpar [openpar, (, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A 
rule: 
matching: id [id, A, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : 
rule: 
matching: colon [colon, :, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float 
rule: 
matching: float [float, float, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
matching: comma [comma, ,, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B 
rule: 
matching: id [id, B, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : 
rule: 
matching: colon [colon, :, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float 
rule: 
matching: float [float, float, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) 
rule: 
matching: closepar [closepar, ), 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
rule: 
matching: semi [semi, ;, 56]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public 
rule: 
matching: public [public, public, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id function 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function 
rule: 
<memberFuncDecl>: function id [CREATE_LEAF: id] colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: memberFuncDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function 
rule: 
matching: function [function, function, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate 
rule: 
matching: id [id, evaluate, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : 
rule: 
matching: colon [colon, :, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( 
rule: 
matching: openpar [openpar, (, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x 
rule: 
matching: id [id, x, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : 
rule: 
matching: colon [colon, :, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float 
rule: 
matching: float [float, float, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) 
rule: 
matching: closepar [closepar, ), 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
matching: float [float, float, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
rule: 
matching: semi [semi, ;, 57]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
matching: closecubr [closecubr, }, 58]
semantic stack: 
[epsilon][class][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
rule: 
matching: semi [semi, ;, 58]
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
matching: class [class, class, 60]
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 60]
semantic stack: 
[epsilon][class][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id isa 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa 
rule: 
<optClassDecl2>: isa id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa 
rule: 
matching: isa [isa, isa, 60]
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 60]
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
rule: 
<multiCommaId>: 
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
rule: 
matching: opencubr [opencubr, {, 60]
semantic stack: 
[epsilon][class][class][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private 
rule: 
matching: private [private, private, 61]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute 
rule: 
matching: attribute [attribute, attribute, 61]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a 
rule: 
matching: id [id, a, 61]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : 
rule: 
matching: colon [colon, :, 61]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float 
rule: 
matching: float [float, float, 61]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
matching: semi [semi, ;, 61]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
matching: private [private, private, 62]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
matching: attribute [attribute, attribute, 62]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b 
rule: 
matching: id [id, b, 62]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : 
rule: 
matching: colon [colon, :, 62]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
matching: float [float, float, 62]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
matching: semi [semi, ;, 62]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private 
rule: 
matching: private [private, private, 63]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute 
rule: 
matching: attribute [attribute, attribute, 63]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c 
rule: 
matching: id [id, c, 63]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : 
rule: 
matching: colon [colon, :, 63]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float 
rule: 
matching: float [float, float, 63]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
rule: 
matching: semi [semi, ;, 63]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public 
rule: 
matching: public [public, public, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon constructor 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor 
rule: 
<memberFuncDecl>: constructor colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: memberConstructorDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor 
rule: 
matching: constructor [constructor, constructor, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : 
rule: 
matching: colon [colon, :, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( 
rule: 
matching: openpar [openpar, (, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A 
rule: 
matching: id [id, A, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : 
rule: 
matching: colon [colon, :, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float 
rule: 
matching: float [float, float, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
matching: comma [comma, ,, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B 
rule: 
matching: id [id, B, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : 
rule: 
matching: colon [colon, :, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float 
rule: 
matching: float [float, float, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
matching: comma [comma, ,, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C 
rule: 
matching: id [id, C, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : 
rule: 
matching: colon [colon, :, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float 
rule: 
matching: float [float, float, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) 
rule: 
matching: closepar [closepar, ), 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
rule: 
matching: semi [semi, ;, 64]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public 
rule: 
matching: public [public, public, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id function 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function 
rule: 
<memberFuncDecl>: function id [CREATE_LEAF: id] colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: memberFuncDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function 
rule: 
matching: function [function, function, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate 
rule: 
matching: id [id, evaluate, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : 
rule: 
matching: colon [colon, :, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( 
rule: 
matching: openpar [openpar, (, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x 
rule: 
matching: id [id, x, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : 
rule: 
matching: colon [colon, :, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float 
rule: 
matching: float [float, float, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) 
rule: 
matching: closepar [closepar, ), 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
matching: float [float, float, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
rule: 
matching: semi [semi, ;, 65]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
matching: closecubr [closecubr, }, 66]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
rule: 
matching: semi [semi, ;, 66]
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
rule: 
skipping
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
matching: function [function, function, 69]
semantic stack: 
[epsilon][class][class][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 69]
semantic stack: 
[epsilon][class][class][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: 
rule: 
matching: scopeop [scopeop, ::, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate 
rule: 
<funcHeadFollowingFuncOrCons>: id [CREATE_LEAF: id] openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: scopedFunctionHead] 
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate 
rule: 
matching: id [id, evaluate, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( 
rule: 
matching: openpar [openpar, (, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x 
rule: 
matching: id [id, x, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : 
rule: 
matching: colon [colon, :, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float 
rule: 
matching: float [float, float, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) 
rule: 
matching: closepar [closepar, ), 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
rule: 
matching: float [float, float, 69]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
rule: 
matching: opencubr [opencubr, {, 70]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return 
rule: 
matching: return [return, return, 71]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 
rule: 
matching: openpar [openpar, (, 71]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 
rule: 
matching: floatnum [floatnum, 0.0, 71]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) 
rule: 
matching: closepar [closepar, ), 71]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; 
rule: 
matching: semi [semi, ;, 71]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
rule: 
matching: closecubr [closecubr, }, 72]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function 
rule: 
matching: function [function, function, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: 
rule: 
matching: scopeop [scopeop, ::, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate 
rule: 
<funcHeadFollowingFuncOrCons>: id [CREATE_LEAF: id] openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: scopedFunctionHead] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate 
rule: 
matching: id [id, evaluate, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( 
rule: 
matching: openpar [openpar, (, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x 
rule: 
matching: id [id, x, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : 
rule: 
matching: colon [colon, :, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float 
rule: 
matching: float [float, float, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) 
rule: 
matching: closepar [closepar, ), 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
rule: 
matching: float [float, float, 74]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
rule: 
matching: opencubr [opencubr, {, 75]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 76]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result 
rule: 
matching: id [id, result, 76]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : 
rule: 
matching: colon [colon, :, 76]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float 
rule: 
matching: float [float, float, 76]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id][float]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
matching: semi [semi, ;, 76]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id][float][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result 
rule: 
matching: id [id, result, 78]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = 
rule: 
matching: assign [assign, =, 78]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a 
rule: 
matching: id [id, a, 78]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; 
rule: 
matching: semi [semi, ;, 78]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result 
rule: 
matching: id [id, result, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = 
rule: 
matching: assign [assign, =, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result 
rule: 
matching: id [id, result, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * 
rule: 
matching: mult [mult, *, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x 
rule: 
matching: id [id, x, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + 
rule: 
matching: plus [plus, +, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b 
rule: 
matching: id [id, b, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; 
rule: 
matching: semi [semi, ;, 79]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result 
rule: 
matching: id [id, result, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = 
rule: 
matching: assign [assign, =, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result 
rule: 
matching: id [id, result, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * 
rule: 
matching: mult [mult, *, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x 
rule: 
matching: id [id, x, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + 
rule: 
matching: plus [plus, +, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c 
rule: 
matching: id [id, c, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; 
rule: 
matching: semi [semi, ;, 80]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return 
rule: 
matching: return [return, return, 81]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( 
rule: 
matching: openpar [openpar, (, 81]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result 
rule: 
matching: id [id, result, 81]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) 
rule: 
matching: closepar [closepar, ), 81]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; 
rule: 
matching: semi [semi, ;, 81]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
rule: 
matching: closecubr [closecubr, }, 82]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function 
rule: 
matching: function [function, function, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: 
rule: 
matching: scopeop [scopeop, ::, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar constructor 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor 
rule: 
<funcHeadFollowingFuncOrCons>: constructor openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: constructorHead] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor 
rule: 
matching: constructor [constructor, constructor, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( 
rule: 
matching: openpar [openpar, (, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A 
rule: 
matching: id [id, A, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : 
rule: 
matching: colon [colon, :, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float 
rule: 
matching: float [float, float, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
matching: comma [comma, ,, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B 
rule: 
matching: id [id, B, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : 
rule: 
matching: colon [colon, :, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float 
rule: 
matching: float [float, float, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
matching: comma [comma, ,, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C 
rule: 
matching: id [id, C, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : 
rule: 
matching: colon [colon, :, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float 
rule: 
matching: float [float, float, 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
rule: 
matching: closepar [closepar, ), 84]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
rule: 
matching: opencubr [opencubr, {, 85]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self 
rule: 
matching: id [self, self, 86]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . 
rule: 
matching: dot [dot, ., 86]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a 
rule: 
matching: id [id, a, 86]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
matching: assign [assign, =, 86]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
matching: id [id, A, 86]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
matching: semi [semi, ;, 86]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
matching: id [self, self, 87]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . 
rule: 
matching: dot [dot, ., 87]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b 
rule: 
matching: id [id, b, 87]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
matching: assign [assign, =, 87]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
matching: id [id, B, 87]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
matching: semi [semi, ;, 87]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self 
rule: 
matching: id [self, self, 88]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . 
rule: 
matching: dot [dot, ., 88]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c 
rule: 
matching: id [id, c, 88]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = 
rule: 
matching: assign [assign, =, 88]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C 
rule: 
matching: id [id, C, 88]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; 
rule: 
matching: semi [semi, ;, 88]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
rule: 
matching: closecubr [closecubr, }, 89]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function 
rule: 
matching: function [function, function, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR 
rule: 
matching: id [id, LINEAR, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: 
rule: 
matching: scopeop [scopeop, ::, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar constructor 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor 
rule: 
<funcHeadFollowingFuncOrCons>: constructor openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: constructorHead] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor 
rule: 
matching: constructor [constructor, constructor, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( 
rule: 
matching: openpar [openpar, (, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A 
rule: 
matching: id [id, A, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : 
rule: 
matching: colon [colon, :, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float 
rule: 
matching: float [float, float, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , 
rule: 
matching: comma [comma, ,, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B 
rule: 
matching: id [id, B, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : 
rule: 
matching: colon [colon, :, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float 
rule: 
matching: float [float, float, 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) 
rule: 
matching: closepar [closepar, ), 91]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
rule: 
matching: opencubr [opencubr, {, 92]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self 
rule: 
matching: id [self, self, 93]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . 
rule: 
matching: dot [dot, ., 93]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a 
rule: 
matching: id [id, a, 93]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = 
rule: 
matching: assign [assign, =, 93]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A 
rule: 
matching: id [id, A, 93]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; 
rule: 
matching: semi [semi, ;, 93]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self 
rule: 
matching: id [self, self, 94]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . 
rule: 
matching: dot [dot, ., 94]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b 
rule: 
matching: id [id, b, 94]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = 
rule: 
matching: assign [assign, =, 94]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B 
rule: 
matching: id [id, B, 94]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; 
rule: 
matching: semi [semi, ;, 94]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
rule: 
matching: closecubr [closecubr, }, 95]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function 
rule: 
matching: function [function, function, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR 
rule: 
matching: id [id, LINEAR, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: 
rule: 
matching: scopeop [scopeop, ::, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate 
rule: 
<funcHeadFollowingFuncOrCons>: id [CREATE_LEAF: id] openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: scopedFunctionHead] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate 
rule: 
matching: id [id, evaluate, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( 
rule: 
matching: openpar [openpar, (, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x 
rule: 
matching: id [id, x, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : 
rule: 
matching: colon [colon, :, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float 
rule: 
matching: float [float, float, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) 
rule: 
matching: closepar [closepar, ), 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float 
rule: 
matching: float [float, float, 97]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
rule: 
matching: opencubr [opencubr, {, 98]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 99]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result 
rule: 
matching: id [id, result, 99]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : 
rule: 
matching: colon [colon, :, 99]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float 
rule: 
matching: float [float, float, 99]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id][float]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; 
rule: 
matching: semi [semi, ;, 99]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id][float][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result 
rule: 
matching: id [id, result, 100]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 
rule: 
matching: assign [assign, =, 100]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 
rule: 
matching: floatnum [floatnum, 0.0, 100]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; 
rule: 
matching: semi [semi, ;, 100]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result 
rule: 
matching: id [id, result, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = 
rule: 
matching: assign [assign, =, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a 
rule: 
matching: id [id, a, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * 
rule: 
matching: mult [mult, *, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x 
rule: 
matching: id [id, x, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + 
rule: 
matching: plus [plus, +, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b 
rule: 
matching: id [id, b, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; 
rule: 
matching: semi [semi, ;, 101]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return 
rule: 
matching: return [return, return, 102]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( 
rule: 
matching: openpar [openpar, (, 102]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result 
rule: 
matching: id [id, result, 102]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) 
rule: 
matching: closepar [closepar, ), 102]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; 
rule: 
matching: semi [semi, ;, 102]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
rule: 
matching: closecubr [closecubr, }, 103]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function 
rule: 
matching: function [function, function, 106]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main 
rule: 
matching: id [id, main, 106]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( 
rule: 
matching: openpar [openpar, (, 106]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) 
rule: 
matching: closepar [closepar, ), 106]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => 
rule: 
matching: returntype [returntype, =>, 106]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void 
rule: 
matching: void [void, void, 106]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
rule: 
matching: opencubr [opencubr, {, 107]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 
rule: 
matching: id [id, f1, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : 
rule: 
matching: colon [colon, :, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR 
rule: 
matching: id [id, LINEAR, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 
rule: 
<localVarDeclFollowing>: openpar [EPSILON: epsilon] <aParams> closepar [CREATE_NODE: aParams] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 
rule: 
matching: openpar [openpar, (, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 
rule: 
matching: intnum [intnum, 2, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <aParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> comma 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
matching: comma [comma, ,, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
matching: floatnum [floatnum, 3.5, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
matching: closepar [closepar, ), 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
rule: 
matching: semi [semi, ;, 108]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][aParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
matching: localvar [localvar, localvar, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 
rule: 
matching: id [id, f2, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : 
rule: 
matching: colon [colon, :, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( 
rule: 
<localVarDeclFollowing>: openpar [EPSILON: epsilon] <aParams> closepar [CREATE_NODE: aParams] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( 
rule: 
matching: openpar [openpar, (, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] <factor> <sign> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 
rule: 
<factor>: <sign> <factor> [CREATE_NODE: signFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] <factor> [CREATE_LEAF: minus] minus 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 
rule: 
<sign>: minus [CREATE_LEAF: minus] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] <factor> [CREATE_LEAF: minus] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 
rule: 
matching: minus [minus, -, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 
rule: 
matching: floatnum [floatnum, 2.0, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][signFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <aParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> comma 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
matching: comma [comma, ,, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
matching: floatnum [floatnum, 1.0, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <aParamsTail> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> comma 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
matching: comma [comma, ,, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
matching: floatnum [floatnum, 0.0, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
matching: closepar [closepar, ), 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
rule: 
matching: semi [semi, ;, 109]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][aParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar 
rule: 
matching: localvar [localvar, localvar, 110]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter 
rule: 
matching: id [id, counter, 110]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : 
rule: 
matching: colon [colon, :, 110]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] float 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float 
rule: 
matching: float [float, float, 110]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][float]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; 
rule: 
matching: semi [semi, ;, 110]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][float][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter 
rule: 
matching: id [id, counter, 112]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 
rule: 
matching: assign [assign, =, 112]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 
rule: 
matching: floatnum [floatnum, 1.0, 112]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; 
rule: 
matching: semi [semi, ;, 112]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while 
rule: 
matching: while [while, while, 114]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( 
rule: 
matching: openpar [openpar, (, 114]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter 
rule: 
matching: id [id, counter, 114]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] leq 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 
rule: 
<relOp>: leq [CREATE_LEAF: leq] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 
rule: 
matching: leq [leq, <=, 114]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 
rule: 
matching: floatnum [floatnum, 10.0, 114]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) 
rule: 
matching: closepar [closepar, ), 114]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
rule: 
matching: opencubr [opencubr, {, 115]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write 
rule: 
matching: write [write, write, 116]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( 
rule: 
matching: openpar [openpar, (, 116]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter 
rule: 
matching: id [id, counter, 116]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) 
rule: 
matching: closepar [closepar, ), 116]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; 
rule: 
matching: semi [semi, ;, 116]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write 
rule: 
matching: write [write, write, 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( 
rule: 
matching: openpar [openpar, (, 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 
rule: 
matching: id [id, f1, 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . 
rule: 
matching: dot [dot, ., 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate 
rule: 
matching: id [id, evaluate, 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( 
rule: 
<idnestFollowing>: openpar <aParams> closepar [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( 
rule: 
matching: openpar [openpar, (, 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter 
rule: 
matching: id [id, counter, 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) 
rule: 
matching: closepar [closepar, ), 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) 
rule: 
matching: closepar [closepar, ), 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; 
rule: 
matching: semi [semi, ;, 117]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write 
rule: 
matching: write [write, write, 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( 
rule: 
matching: openpar [openpar, (, 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 
rule: 
matching: id [id, f2, 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . 
rule: 
matching: dot [dot, ., 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate 
rule: 
matching: id [id, evaluate, 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> openpar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( 
rule: 
<idnestFollowing>: openpar <aParams> closepar [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( 
rule: 
matching: openpar [openpar, (, 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter 
rule: 
matching: id [id, counter, 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) 
rule: 
matching: closepar [closepar, ), 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) 
rule: 
matching: closepar [closepar, ), 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; 
rule: 
matching: semi [semi, ;, 118]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter 
rule: 
matching: id [id, counter, 119]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = 
rule: 
matching: assign [assign, =, 119]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter 
rule: 
matching: id [id, counter, 119]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 
rule: 
matching: plus [plus, +, 119]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 
rule: 
matching: floatnum [floatnum, 1.0, 119]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; 
rule: 
matching: semi [semi, ;, 119]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; // 3.1  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; // 3.1  
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; // 3.1  
} 
rule: 
matching: closecubr [closecubr, }, 120]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; // 3.1  
} ; 
rule: 
matching: semi [semi, ;, 120]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; // 3.1  
} ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; // 3.1  
} ; 
} 
rule: 
matching: closecubr [closecubr, }, 121]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> 
input: 
/* 
1.1  Allocate memory for basic types (integer, float). 
1.2  Allocate memory for arrays of basic types. 
1.3  Allocate memory for objects. 
1.4  Allocate memory for arrays of objects. 
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function. 
2.2  Pass parameters as local values to the functionâs code block. 
2.3  Upon execution of a return statement, pass the return value back to the calling function. 
2.4  Call to member functions that can use their objectâs data members. 
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator. 
3.2 Conditional statement: implementation of a branching mechanism. 
3.3 Loop statement: implementation of a branching mechanism. 
3.4 Input/output statement: Moon machine keyboard input/console output 
4.1. For arrays of basic types (integer and float), access to an arrayâs elements. 
4.2. For arrays of objects, access to an arrayâs elementâs data members. 
4.3. For objects, access to members of basic types. 
4.4. For objects, access to members of array or object types. 
5.1. Computing the value of an entire complex expression. 
5.2. Expression involving an array factor whose indexes are themselves expressions. 
5.3. Expression involving an object factor referring to object members. 
*/ 
// Assignment 5 coverage:  
//      -------------  
//      | YES | NO  |  
//      -------------   
// 1.1: |  X  |     |  
// 1.2: |  X  |     |  
// 1.3: |  X  |     |  
// 1.4: |     |  X  |  
// 2.1: |  X  |     |  
// 2.2: |  X  |     |  
// 2.3: |  X  |     |  
// 2.4: |  X  |     |  
// 3.1: |  X  |     |  
// 3.2: |  X  |     |  
// 3.3: |  X  |     |  
// 3.4: |  X  |     |  
// 4.1: |     |  X  |  
// 4.2: |     |  X  |  
// 4.3: |  X  |     |  
// 4.4: |  X  |     |  
// 5.1: |  X  |     |  
// 5.2: |     |  X  |  
// 5.3: |  X  |     |  
//      -------------  
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
return ( 0.0 ) ; // 2.3  
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; // 1.1  
//Using Horner's method  
result = a ; // 3.1         
result = result * x + b ; // 3.1, 5.1  
result = result * x + c ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
self . c = C ; // 3.1, 5.3  
} 
function LINEAR :: constructor ( A : float , B : float ) // 2.1, 2.2  
{ 
self . a = A ; // 3.1, 5.3  
self . b = B ; // 3.1, 5.3  
} 
function LINEAR :: evaluate ( x : float ) => float // 2.1, 2.2  
{ 
localvar result : float ; // 1.1  
result = 0.0 ; // 3.1  
result = a * x + b ; // 3.1, 5.1  
return ( result ) ; // 2.3  
} 
// ====== main ====== //  
function main ( ) => void // 2.1, 2.2  
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; // 1.3, 2.1, 2.2, 2.4  
localvar counter : float ; // 1.1  
counter = 1.0 ; // 3.1  
while ( counter <= 10.0 ) // 3.3, 5.1  
{ 
write ( counter ) ; // 3.4  
write ( f1 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
write ( f2 . evaluate ( counter ) ) ; // 3.4, 2.1, 2.2, 2.4  
counter = counter + 1.0 ; // 3.1  
} ; 
} 
rule: 
<multiClassDeclOrFuncDef>: 
semantic stack: 
[program]
-----------------------------------------------------------------------
