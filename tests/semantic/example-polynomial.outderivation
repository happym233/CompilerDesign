stack: 
<$> <START> 
input: 
// ====== struct declarations ====== //  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class 
rule: 
<START>: [EPSILON: epsilon] <multiClassDeclOrFuncDef> [CREATE_NODE: program] 
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
// ====== struct declarations ====== //  
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
// ====== struct declarations ====== //  
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class 
rule: 
matching: class [class, class, 2]
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 2]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
rule: 
<optClassDecl2>: 
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
rule: 
matching: opencubr [opencubr, {, 2]
semantic stack: 
[epsilon][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public 
rule: 
matching: public [public, public, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id function 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function 
rule: 
<memberFuncDecl>: function id [CREATE_LEAF: id] colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: memberFuncDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function 
rule: 
matching: function [function, function, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate 
rule: 
matching: id [id, evaluate, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : 
rule: 
matching: colon [colon, :, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( 
rule: 
matching: openpar [openpar, (, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x 
rule: 
matching: id [id, x, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : 
rule: 
matching: colon [colon, :, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float 
rule: 
matching: float [float, float, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) 
rule: 
matching: closepar [closepar, ), 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float 
rule: 
matching: float [float, float, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
rule: 
matching: semi [semi, ;, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
matching: closecubr [closecubr, }, 4]
semantic stack: 
[epsilon][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
rule: 
matching: semi [semi, ;, 4]
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
matching: class [class, class, 6]
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR 
rule: 
matching: id [id, LINEAR, 6]
semantic stack: 
[epsilon][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id isa 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa 
rule: 
<optClassDecl2>: isa id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa 
rule: 
matching: isa [isa, isa, 6]
semantic stack: 
[epsilon][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 6]
semantic stack: 
[epsilon][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
rule: 
<multiCommaId>: 
semantic stack: 
[epsilon][class][epsilon][id][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
rule: 
matching: opencubr [opencubr, {, 6]
semantic stack: 
[epsilon][class][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private 
rule: 
matching: private [private, private, 7]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute 
rule: 
matching: attribute [attribute, attribute, 7]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a 
rule: 
matching: id [id, a, 7]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : 
rule: 
matching: colon [colon, :, 7]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float 
rule: 
matching: float [float, float, 7]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
matching: semi [semi, ;, 7]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
matching: private [private, private, 8]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
matching: attribute [attribute, attribute, 8]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b 
rule: 
matching: id [id, b, 8]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : 
rule: 
matching: colon [colon, :, 8]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
matching: float [float, float, 8]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
matching: semi [semi, ;, 8]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public 
rule: 
matching: public [public, public, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon constructor 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor 
rule: 
<memberFuncDecl>: constructor colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: memberConstructorDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor 
rule: 
matching: constructor [constructor, constructor, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : 
rule: 
matching: colon [colon, :, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( 
rule: 
matching: openpar [openpar, (, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A 
rule: 
matching: id [id, A, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : 
rule: 
matching: colon [colon, :, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float 
rule: 
matching: float [float, float, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , 
rule: 
matching: comma [comma, ,, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B 
rule: 
matching: id [id, B, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : 
rule: 
matching: colon [colon, :, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float 
rule: 
matching: float [float, float, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) 
rule: 
matching: closepar [closepar, ), 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
rule: 
matching: semi [semi, ;, 9]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public 
rule: 
matching: public [public, public, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id function 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function 
rule: 
<memberFuncDecl>: function id [CREATE_LEAF: id] colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: memberFuncDecl] semi 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function 
rule: 
matching: function [function, function, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate 
rule: 
matching: id [id, evaluate, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : 
rule: 
matching: colon [colon, :, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( 
rule: 
matching: openpar [openpar, (, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x 
rule: 
matching: id [id, x, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : 
rule: 
matching: colon [colon, :, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float 
rule: 
matching: float [float, float, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) 
rule: 
matching: closepar [closepar, ), 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
matching: float [float, float, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
rule: 
matching: semi [semi, ;, 10]
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
matching: closecubr [closecubr, }, 11]
semantic stack: 
[epsilon][class][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
rule: 
matching: semi [semi, ;, 11]
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class 
rule: 
matching: class [class, class, 13]
semantic stack: 
[epsilon][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 13]
semantic stack: 
[epsilon][class][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id isa 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa 
rule: 
<optClassDecl2>: isa id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa 
rule: 
matching: isa [isa, isa, 13]
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 13]
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
rule: 
<multiCommaId>: 
semantic stack: 
[epsilon][class][class][epsilon][id][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
rule: 
matching: opencubr [opencubr, {, 13]
semantic stack: 
[epsilon][class][class][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private 
rule: 
matching: private [private, private, 14]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute 
rule: 
matching: attribute [attribute, attribute, 14]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a 
rule: 
matching: id [id, a, 14]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : 
rule: 
matching: colon [colon, :, 14]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float 
rule: 
matching: float [float, float, 14]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
rule: 
matching: semi [semi, ;, 14]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private 
rule: 
matching: private [private, private, 15]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute 
rule: 
matching: attribute [attribute, attribute, 15]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b 
rule: 
matching: id [id, b, 15]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : 
rule: 
matching: colon [colon, :, 15]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float 
rule: 
matching: float [float, float, 15]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
rule: 
matching: semi [semi, ;, 15]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private 
rule: 
matching: private [private, private, 16]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute 
rule: 
matching: attribute [attribute, attribute, 16]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c 
rule: 
matching: id [id, c, 16]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : 
rule: 
matching: colon [colon, :, 16]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float 
rule: 
matching: float [float, float, 16]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
rule: 
matching: semi [semi, ;, 16]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public 
rule: 
matching: public [public, public, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon constructor 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor 
rule: 
<memberFuncDecl>: constructor colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: memberConstructorDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor 
rule: 
matching: constructor [constructor, constructor, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : 
rule: 
matching: colon [colon, :, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( 
rule: 
matching: openpar [openpar, (, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A 
rule: 
matching: id [id, A, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : 
rule: 
matching: colon [colon, :, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float 
rule: 
matching: float [float, float, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , 
rule: 
matching: comma [comma, ,, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B 
rule: 
matching: id [id, B, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : 
rule: 
matching: colon [colon, :, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float 
rule: 
matching: float [float, float, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , 
rule: 
matching: comma [comma, ,, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C 
rule: 
matching: id [id, C, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : 
rule: 
matching: colon [colon, :, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float 
rule: 
matching: float [float, float, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) 
rule: 
matching: closepar [closepar, ), 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
rule: 
matching: semi [semi, ;, 17]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public 
rule: 
matching: public [public, public, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id function 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function 
rule: 
<memberFuncDecl>: function id [CREATE_LEAF: id] colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: memberFuncDecl] semi 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function 
rule: 
matching: function [function, function, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate 
rule: 
matching: id [id, evaluate, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : 
rule: 
matching: colon [colon, :, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( 
rule: 
matching: openpar [openpar, (, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x 
rule: 
matching: id [id, x, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : 
rule: 
matching: colon [colon, :, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float 
rule: 
matching: float [float, float, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> returntype 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) 
rule: 
matching: closepar [closepar, ), 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] <returnType> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberFuncDecl] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float 
rule: 
matching: float [float, float, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][epsilon][visibility][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
rule: 
matching: semi [semi, ;, 18]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][class][class][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl][memberFuncDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} 
rule: 
matching: closecubr [closecubr, }, 19]
semantic stack: 
[epsilon][class][class][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
rule: 
matching: semi [semi, ;, 19]
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
rule: 
skipping
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function 
rule: 
matching: function [function, function, 22]
semantic stack: 
[epsilon][class][class][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL 
rule: 
matching: id [id, POLYNOMIAL, 22]
semantic stack: 
[epsilon][class][class][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: 
rule: 
matching: scopeop [scopeop, ::, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate 
rule: 
<funcHeadFollowingFuncOrCons>: id [CREATE_LEAF: id] openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: scopedFunctionHead] 
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate 
rule: 
matching: id [id, evaluate, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( 
rule: 
matching: openpar [openpar, (, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x 
rule: 
matching: id [id, x, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : 
rule: 
matching: colon [colon, :, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float 
rule: 
matching: float [float, float, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) 
rule: 
matching: closepar [closepar, ), 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
rule: 
matching: float [float, float, 22]
semantic stack: 
[epsilon][class][class][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
rule: 
matching: opencubr [opencubr, {, 23]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return 
rule: 
matching: return [return, return, 24]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 
rule: 
matching: openpar [openpar, (, 24]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 
rule: 
matching: intnum [intnum, 0, 24]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) 
rule: 
matching: closepar [closepar, ), 24]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
rule: 
matching: semi [semi, ;, 24]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 25]
semantic stack: 
[epsilon][class][class][class][scopedFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function 
rule: 
matching: function [function, function, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: 
rule: 
matching: scopeop [scopeop, ::, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate 
rule: 
<funcHeadFollowingFuncOrCons>: id [CREATE_LEAF: id] openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: scopedFunctionHead] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate 
rule: 
matching: id [id, evaluate, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( 
rule: 
matching: openpar [openpar, (, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x 
rule: 
matching: id [id, x, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : 
rule: 
matching: colon [colon, :, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float 
rule: 
matching: float [float, float, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) 
rule: 
matching: closepar [closepar, ), 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
rule: 
matching: float [float, float, 27]
semantic stack: 
[epsilon][class][class][class][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
rule: 
matching: opencubr [opencubr, {, 28]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 29]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result 
rule: 
matching: id [id, result, 29]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : 
rule: 
matching: colon [colon, :, 29]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float 
rule: 
matching: float [float, float, 29]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id][float]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
matching: semi [semi, ;, 29]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][epsilon][id][float][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result 
rule: 
matching: id [id, result, 31]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = 
rule: 
matching: assign [assign, =, 31]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a 
rule: 
matching: id [id, a, 31]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
rule: 
matching: semi [semi, ;, 31]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result 
rule: 
matching: id [id, result, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = 
rule: 
matching: assign [assign, =, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result 
rule: 
matching: id [id, result, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * 
rule: 
matching: mult [mult, *, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x 
rule: 
matching: id [id, x, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + 
rule: 
matching: plus [plus, +, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b 
rule: 
matching: id [id, b, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
rule: 
matching: semi [semi, ;, 32]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result 
rule: 
matching: id [id, result, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = 
rule: 
matching: assign [assign, =, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result 
rule: 
matching: id [id, result, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * 
rule: 
matching: mult [mult, *, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x 
rule: 
matching: id [id, x, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + 
rule: 
matching: plus [plus, +, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c 
rule: 
matching: id [id, c, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
rule: 
matching: semi [semi, ;, 33]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return 
rule: 
matching: return [return, return, 34]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( 
rule: 
matching: openpar [openpar, (, 34]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result 
rule: 
matching: id [id, result, 34]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) 
rule: 
matching: closepar [closepar, ), 34]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
rule: 
matching: semi [semi, ;, 34]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 35]
semantic stack: 
[epsilon][class][class][class][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function 
rule: 
matching: function [function, function, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: 
rule: 
matching: scopeop [scopeop, ::, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar constructor 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor 
rule: 
<funcHeadFollowingFuncOrCons>: constructor openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: constructorHead] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor 
rule: 
matching: constructor [constructor, constructor, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( 
rule: 
matching: openpar [openpar, (, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A 
rule: 
matching: id [id, A, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : 
rule: 
matching: colon [colon, :, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float 
rule: 
matching: float [float, float, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , 
rule: 
matching: comma [comma, ,, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B 
rule: 
matching: id [id, B, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : 
rule: 
matching: colon [colon, :, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float 
rule: 
matching: float [float, float, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , 
rule: 
matching: comma [comma, ,, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C 
rule: 
matching: id [id, C, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : 
rule: 
matching: colon [colon, :, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float 
rule: 
matching: float [float, float, 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][epsilon][fParam][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
rule: 
matching: closepar [closepar, ), 37]
semantic stack: 
[epsilon][class][class][class][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
rule: 
matching: opencubr [opencubr, {, 38]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self 
rule: 
matching: id [self, self, 39]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . 
rule: 
matching: dot [dot, ., 39]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a 
rule: 
matching: id [id, a, 39]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = 
rule: 
matching: assign [assign, =, 39]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A 
rule: 
matching: id [id, A, 39]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
rule: 
matching: semi [semi, ;, 39]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self 
rule: 
matching: id [self, self, 40]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . 
rule: 
matching: dot [dot, ., 40]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b 
rule: 
matching: id [id, b, 40]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
matching: assign [assign, =, 40]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
matching: id [id, B, 40]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
matching: semi [semi, ;, 40]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self 
rule: 
matching: id [self, self, 41]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . 
rule: 
matching: dot [dot, ., 41]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c 
rule: 
matching: id [id, c, 41]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = 
rule: 
matching: assign [assign, =, 41]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C 
rule: 
matching: id [id, C, 41]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
rule: 
matching: semi [semi, ;, 41]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
rule: 
matching: closecubr [closecubr, }, 42]
semantic stack: 
[epsilon][class][class][class][function][function][constructorHead][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function 
rule: 
matching: function [function, function, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR 
rule: 
matching: id [id, LINEAR, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: 
rule: 
matching: scopeop [scopeop, ::, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar constructor 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor 
rule: 
<funcHeadFollowingFuncOrCons>: constructor openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: constructorHead] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor 
rule: 
matching: constructor [constructor, constructor, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( 
rule: 
matching: openpar [openpar, (, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A 
rule: 
matching: id [id, A, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : 
rule: 
matching: colon [colon, :, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float 
rule: 
matching: float [float, float, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , 
rule: 
matching: comma [comma, ,, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B 
rule: 
matching: id [id, B, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : 
rule: 
matching: colon [colon, :, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float 
rule: 
matching: float [float, float, 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: constructorHead] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
rule: 
matching: closepar [closepar, ), 44]
semantic stack: 
[epsilon][class][class][class][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
rule: 
matching: opencubr [opencubr, {, 45]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self 
rule: 
matching: id [self, self, 46]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . 
rule: 
matching: dot [dot, ., 46]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a 
rule: 
matching: id [id, a, 46]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = 
rule: 
matching: assign [assign, =, 46]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A 
rule: 
matching: id [id, A, 46]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
rule: 
matching: semi [semi, ;, 46]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self 
rule: 
matching: id [self, self, 47]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . 
rule: 
matching: dot [dot, ., 47]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b 
rule: 
matching: id [id, b, 47]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = 
rule: 
matching: assign [assign, =, 47]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B 
rule: 
matching: id [id, B, 47]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
rule: 
matching: semi [semi, ;, 47]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
rule: 
matching: closecubr [closecubr, }, 48]
semantic stack: 
[epsilon][class][class][class][function][function][function][constructorHead][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function 
rule: 
matching: function [function, function, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR 
rule: 
matching: id [id, LINEAR, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: 
rule: 
matching: scopeop [scopeop, ::, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate 
rule: 
<funcHeadFollowingFuncOrCons>: id [CREATE_LEAF: id] openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: scopedFunctionHead] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate 
rule: 
matching: id [id, evaluate, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( 
rule: 
matching: openpar [openpar, (, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x 
rule: 
matching: id [id, x, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : 
rule: 
matching: colon [colon, :, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float 
rule: 
matching: float [float, float, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) 
rule: 
matching: closepar [closepar, ), 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => 
rule: 
matching: returntype [returntype, =>, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
rule: 
matching: float [float, float, 50]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
rule: 
matching: opencubr [opencubr, {, 51]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 52]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result 
rule: 
matching: id [id, result, 52]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : 
rule: 
matching: colon [colon, :, 52]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] float 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: float] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float 
rule: 
matching: float [float, float, 52]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id][float]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
rule: 
matching: semi [semi, ;, 52]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][epsilon][id][float][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result 
rule: 
matching: id [id, result, 53]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 
rule: 
matching: assign [assign, =, 53]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 
rule: 
matching: floatnum [floatnum, 0.0, 53]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
rule: 
matching: semi [semi, ;, 53]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result 
rule: 
matching: id [id, result, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = 
rule: 
matching: assign [assign, =, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a 
rule: 
matching: id [id, a, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * 
rule: 
matching: mult [mult, *, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x 
rule: 
matching: id [id, x, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor][mult][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + 
rule: 
matching: plus [plus, +, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b 
rule: 
matching: id [id, b, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
rule: 
matching: semi [semi, ;, 54]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return 
rule: 
matching: return [return, return, 55]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( 
rule: 
matching: openpar [openpar, (, 55]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result 
rule: 
matching: id [id, result, 55]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) 
rule: 
matching: closepar [closepar, ), 55]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
rule: 
matching: semi [semi, ;, 55]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 56]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][scopedFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function 
rule: 
matching: function [function, function, 59]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main 
rule: 
matching: id [id, main, 59]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( 
rule: 
matching: openpar [openpar, (, 59]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) 
rule: 
matching: closepar [closepar, ), 59]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => 
rule: 
matching: returntype [returntype, =>, 59]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
rule: 
matching: void [void, void, 59]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
rule: 
matching: opencubr [opencubr, {, 60]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 
rule: 
matching: id [id, f1, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : 
rule: 
matching: colon [colon, :, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR 
rule: 
matching: id [id, LINEAR, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 
rule: 
<localVarDeclFollowing>: openpar [EPSILON: epsilon] <aParams> closepar [CREATE_NODE: aParams] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 
rule: 
matching: openpar [openpar, (, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 
rule: 
matching: intnum [intnum, 2, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <aParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> comma 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 
rule: 
matching: comma [comma, ,, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 
rule: 
matching: floatnum [floatnum, 3.5, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) 
rule: 
matching: closepar [closepar, ), 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
rule: 
matching: semi [semi, ;, 61]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][epsilon][id][id][aParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar 
rule: 
matching: localvar [localvar, localvar, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 
rule: 
matching: id [id, f2, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : 
rule: 
matching: colon [colon, :, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC 
rule: 
matching: id [id, QUADRATIC, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( 
rule: 
<localVarDeclFollowing>: openpar [EPSILON: epsilon] <aParams> closepar [CREATE_NODE: aParams] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <aParams> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( 
rule: 
matching: openpar [openpar, (, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] <factor> <sign> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 
rule: 
<factor>: <sign> <factor> [CREATE_NODE: signFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] <factor> [CREATE_LEAF: minus] minus 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 
rule: 
<sign>: minus [CREATE_LEAF: minus] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] <factor> [CREATE_LEAF: minus] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 
rule: 
matching: minus [minus, -, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: signFactor] [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 
rule: 
matching: floatnum [floatnum, 2.0, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][epsilon][signFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <aParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> comma 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 
rule: 
matching: comma [comma, ,, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 
rule: 
matching: floatnum [floatnum, 1.0, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <aParamsTail> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> comma 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 
rule: 
matching: comma [comma, ,, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] floatnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
<factor>: floatnum [CREATE_LEAF: floatnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: floatnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 
rule: 
matching: floatnum [floatnum, 0.0, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] closepar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: aParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) 
rule: 
matching: closepar [closepar, ), 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][expr][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
rule: 
matching: semi [semi, ;, 62]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][aParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar 
rule: 
matching: localvar [localvar, localvar, 63]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter 
rule: 
matching: id [id, counter, 63]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : 
rule: 
matching: colon [colon, :, 63]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer 
rule: 
matching: integer [integer, integer, 63]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
rule: 
matching: semi [semi, ;, 63]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter 
rule: 
matching: id [id, counter, 64]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 
rule: 
matching: assign [assign, =, 64]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 
rule: 
matching: intnum [intnum, 1, 64]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
rule: 
matching: semi [semi, ;, 64]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while 
rule: 
matching: while [while, while, 66]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( 
rule: 
matching: openpar [openpar, (, 66]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter 
rule: 
matching: id [id, counter, 66]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] leq 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 
rule: 
<relOp>: leq [CREATE_LEAF: leq] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 
rule: 
matching: leq [leq, <=, 66]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 
rule: 
matching: intnum [intnum, 10, 66]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr][leq][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
rule: 
matching: closepar [closepar, ), 66]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
rule: 
matching: opencubr [opencubr, {, 67]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write 
rule: 
matching: write [write, write, 68]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( 
rule: 
matching: openpar [openpar, (, 68]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter 
rule: 
matching: id [id, counter, 68]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) 
rule: 
matching: closepar [closepar, ), 68]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
rule: 
matching: semi [semi, ;, 68]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write 
rule: 
matching: write [write, write, 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( 
rule: 
matching: openpar [openpar, (, 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 
rule: 
matching: id [id, f1, 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . 
rule: 
matching: dot [dot, ., 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate 
rule: 
matching: id [id, evaluate, 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> openpar [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( 
rule: 
<idnestFollowing>: [EPSILON: epsilon] openpar <aParams> closepar [CREATE_NODE: aParams] [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( 
rule: 
matching: openpar [openpar, (, 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter 
rule: 
matching: id [id, counter, 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) 
rule: 
matching: closepar [closepar, ), 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) 
rule: 
matching: closepar [closepar, ), 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
rule: 
matching: semi [semi, ;, 69]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write 
rule: 
matching: write [write, write, 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( 
rule: 
matching: openpar [openpar, (, 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 
rule: 
matching: id [id, f2, 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . 
rule: 
matching: dot [dot, ., 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate 
rule: 
matching: id [id, evaluate, 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> openpar [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( 
rule: 
<idnestFollowing>: [EPSILON: epsilon] openpar <aParams> closepar [CREATE_NODE: aParams] [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( 
rule: 
matching: openpar [openpar, (, 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter 
rule: 
matching: id [id, counter, 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) 
rule: 
matching: closepar [closepar, ), 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) 
rule: 
matching: closepar [closepar, ), 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
rule: 
matching: semi [semi, ;, 70]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 71]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileCondition][epsilon][writeStatement][writeStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
} ; 
rule: 
matching: semi [semi, ;, 71]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
} ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
} ; 
} 
rule: 
matching: closecubr [closecubr, }, 72]
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
} ; 
} 
/* 
    classes 
    -------------------------------------- 
| | no class declaration 
| | class declaration 
|X| multiple class declarations 
|X| no data member declaration 
|X| data member declaration 
|X| multiple data member declaration 
| | no member function declaration 
|X| member function declaration 
|X| multiple member function declaration 
| | no member 
|X| no inherited class 
|X| one inherited class 
| | multiple inherited classes 
|X| private member specifier 
|X| public member specifier 
 
    functions: definitions 
    -------------------------------------- 
| | no main function definition 
|X| main function definition 
|X| no free function definition 
| | free function definition 
| | multiple free function definitions 
| | no member function definition 
|X| member function definition 
|X| multiple member function definitions 
| | return type: void 
| | return type: integer 
|X| return type: float 
|X| return type: id 
| | return type: array (not allowed) 
 
    functions: formal parameters 
    -------------------------------------- 
| | type: integer 
|X| type: float 
| | type: id 
| | type: 1-dim array  
| | type: n-dim array 
| | type: array (with size) 
| | type: array (without size) 
 
    functions: calls 
    -------------------------------------- 
| | free function call 
|X| member function call 
| | parameters:0 
|X| parameters:1 
|X| parameters:n 
| | array parameter - 1-dim 
| | array parameter - n-dim 
| | array parameter - with size 
| | array parameter - without size 
| | function call as statement 
|X| function call as expression factor 
| | expression as parameter 
 
    variable declaration 
    -------------------------------------- 
| | type: integer 
| | type: float 
| | type: string 
|X| type: id 
| | type: 1-dim array  
| | type: n-dim array 
| | type: array (with size) 
| | type: array (without size) 
 
    function body: local variable declarations 
    -------------------------------------- 
| | no local variable declarations 
|X| local variable declarations 
| | intertwined statements and variable declarations 
 
    function body: statements 
    -------------------------------------- 
| | no statement 
| | 1 statement 
|X| n statements 
| | if statement 
| | if: empty then or else blocks 
| | if: 1-statement then or else blocks 
| | if: n-statements then or else blocks 
|X| while statement 
| | while: empty block 
| | while: 1-statement block 
|X| while: n-statement block 
| | read(<variable>) statement 
|X| write(<expr>) statement 
|X| return(<expr>) statement 
|X| assignment statement 
 
    variable + idnest 
    -------------------------------------- 
|X| id 
|X| id.id 
|X| id.id(id) 
| | id(id).id 
| | id(id).id() 
| | id.id[id] 
| | id[id].id 
| | id[id].id[id] 
| | id.id[id][id] 
| | id[id][id].id 
| | id[id][id].id[id][id] 
| | id(id).id[id] 
| | id(id).id[id][id] 
| | expression as array index 
 
    expressions 
    -------------------------------------- 
| | single variable 
| | involving addop 
| | involving multop 
| | involving relop 
|X| involving addop + multop 
| | involving multop + relop 
| | involving addop + multop + relop 
| | involving parentheses 
| | involving nested parenhteses 
| | involving not 
| | involving sign 
| | involving literals 
|X| involving variable + idnest 
|X| involving function calls 
| | involving all the above in one expression 
*/ 
rule: 
skipping
semantic stack: 
[epsilon][class][class][class][function][function][function][function][function][function]
-----------------------------------------------------------------------
stack: 
<$> 
input: 
// ====== struct declarations ====== //  
class POLYNOMIAL { 
public function evaluate : ( x : float ) => float ; 
} ; 
class LINEAR isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
public constructor : ( A : float , B : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
class QUADRATIC isa POLYNOMIAL { 
private attribute a : float ; 
private attribute b : float ; 
private attribute c : float ; 
public constructor : ( A : float , B : float , C : float ) ; 
public function evaluate : ( x : float ) => float ; 
} ; 
// ====== member function implementations ====== //    
function POLYNOMIAL :: evaluate ( x : float ) => float 
{ 
return ( 0 ) ; 
} 
function QUADRATIC :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
//Using Horner's method  
result = a ; 
result = result * x + b ; 
result = result * x + c ; 
return ( result ) ; 
} 
function QUADRATIC :: constructor ( A : float , B : float , C : float ) 
{ 
self . a = A ; 
self . b = B ; 
self . c = C ; 
} 
function LINEAR :: constructor ( A : float , B : float ) 
{ 
self . a = A ; 
self . b = B ; 
} 
function LINEAR :: evaluate ( x : float ) => float 
{ 
localvar result : float ; 
result = 0.0 ; 
result = a * x + b ; 
return ( result ) ; 
} 
// ====== main ====== //  
function main ( ) => void 
{ 
localvar f1 : LINEAR ( 2 , 3.5 ) ; 
localvar f2 : QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; 
localvar counter : integer ; 
counter = 1 ; 
while ( counter <= 10 ) 
{ 
write ( counter ) ; 
write ( f1 . evaluate ( counter ) ) ; 
write ( f2 . evaluate ( counter ) ) ; 
} ; 
} 
/* 
    classes 
    -------------------------------------- 
| | no class declaration 
| | class declaration 
|X| multiple class declarations 
|X| no data member declaration 
|X| data member declaration 
|X| multiple data member declaration 
| | no member function declaration 
|X| member function declaration 
|X| multiple member function declaration 
| | no member 
|X| no inherited class 
|X| one inherited class 
| | multiple inherited classes 
|X| private member specifier 
|X| public member specifier 
 
    functions: definitions 
    -------------------------------------- 
| | no main function definition 
|X| main function definition 
|X| no free function definition 
| | free function definition 
| | multiple free function definitions 
| | no member function definition 
|X| member function definition 
|X| multiple member function definitions 
| | return type: void 
| | return type: integer 
|X| return type: float 
|X| return type: id 
| | return type: array (not allowed) 
 
    functions: formal parameters 
    -------------------------------------- 
| | type: integer 
|X| type: float 
| | type: id 
| | type: 1-dim array  
| | type: n-dim array 
| | type: array (with size) 
| | type: array (without size) 
 
    functions: calls 
    -------------------------------------- 
| | free function call 
|X| member function call 
| | parameters:0 
|X| parameters:1 
|X| parameters:n 
| | array parameter - 1-dim 
| | array parameter - n-dim 
| | array parameter - with size 
| | array parameter - without size 
| | function call as statement 
|X| function call as expression factor 
| | expression as parameter 
 
    variable declaration 
    -------------------------------------- 
| | type: integer 
| | type: float 
| | type: string 
|X| type: id 
| | type: 1-dim array  
| | type: n-dim array 
| | type: array (with size) 
| | type: array (without size) 
 
    function body: local variable declarations 
    -------------------------------------- 
| | no local variable declarations 
|X| local variable declarations 
| | intertwined statements and variable declarations 
 
    function body: statements 
    -------------------------------------- 
| | no statement 
| | 1 statement 
|X| n statements 
| | if statement 
| | if: empty then or else blocks 
| | if: 1-statement then or else blocks 
| | if: n-statements then or else blocks 
|X| while statement 
| | while: empty block 
| | while: 1-statement block 
|X| while: n-statement block 
| | read(<variable>) statement 
|X| write(<expr>) statement 
|X| return(<expr>) statement 
|X| assignment statement 
 
    variable + idnest 
    -------------------------------------- 
|X| id 
|X| id.id 
|X| id.id(id) 
| | id(id).id 
| | id(id).id() 
| | id.id[id] 
| | id[id].id 
| | id[id].id[id] 
| | id.id[id][id] 
| | id[id][id].id 
| | id[id][id].id[id][id] 
| | id(id).id[id] 
| | id(id).id[id][id] 
| | expression as array index 
 
    expressions 
    -------------------------------------- 
| | single variable 
| | involving addop 
| | involving multop 
| | involving relop 
|X| involving addop + multop 
| | involving multop + relop 
| | involving addop + multop + relop 
| | involving parentheses 
| | involving nested parenhteses 
| | involving not 
| | involving sign 
| | involving literals 
|X| involving variable + idnest 
|X| involving function calls 
| | involving all the above in one expression 
*/ 
rule: 
<multiClassDeclOrFuncDef>: 
semantic stack: 
[program]
-----------------------------------------------------------------------
