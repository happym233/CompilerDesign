stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [EPSILON: epsilon] 
input: 
class 
rule: 
<START>: [EPSILON: epsilon] <multiClassDeclOrFuncDef> [CREATE_NODE: program] 
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class 
rule: 
matching: class [class, class, 1]
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
class A 
rule: 
matching: id [id, A, 1]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id isa 
input: 
class A isa 
rule: 
<optClassDecl2>: isa id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
class A isa 
rule: 
matching: isa [isa, isa, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
class A isa B 
rule: 
matching: id [id, B, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id comma 
input: 
class A isa B , 
rule: 
<multiCommaId>: comma id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][epsilon][id][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
class A isa B , 
rule: 
matching: comma [comma, ,, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
class A isa B , C 
rule: 
matching: id [id, C, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id comma 
input: 
class A isa B , C , 
rule: 
<multiCommaId>: comma id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][epsilon][id][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
class A isa B , C , 
rule: 
matching: comma [comma, ,, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
class A isa B , C , D 
rule: 
matching: id [id, D, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id comma 
input: 
class A isa B , C , D , 
rule: 
<multiCommaId>: comma id [CREATE_LEAF: id] <multiCommaId> 
semantic stack: 
[epsilon][epsilon][id][epsilon][id][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , 
rule: 
matching: comma [comma, ,, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon][id][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <multiCommaId> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E 
rule: 
matching: id [id, E, 1]
semantic stack: 
[epsilon][epsilon][id][epsilon][id][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
class A isa B , C , D , E { 
rule: 
<multiCommaId>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][id][id][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
rule: 
matching: opencubr [opencubr, {, 1]
semantic stack: 
[epsilon][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] 
input: 
class A isa B , C , D , E { 
attribute 
rule: 
<visibility>: [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
class A isa B , C , D , E { 
attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
class A isa B , C , D , E { 
attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute 
rule: 
matching: attribute [attribute, attribute, 2]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c 
rule: 
matching: id [id, c, 2]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
class A isa B , C , D , E { 
attribute c : 
rule: 
matching: colon [colon, :, 2]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
class A isa B , C , D , E { 
attribute c : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
class A isa B , C , D , E { 
attribute c : integer 
rule: 
matching: integer [integer, integer, 2]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
rule: 
matching: semi [semi, ;, 2]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] private 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private 
rule: 
<visibility>: private [CREATE_LEAF: private] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: private] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private 
rule: 
matching: private [private, private, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute 
rule: 
matching: attribute [attribute, attribute, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b 
rule: 
matching: id [id, b, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : 
rule: 
matching: colon [colon, :, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float 
rule: 
matching: float [float, float, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
rule: 
matching: semi [semi, ;, 3]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public 
rule: 
matching: public [public, public, 4]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute 
rule: 
matching: attribute [attribute, attribute, 4]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d 
rule: 
matching: id [id, d, 4]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : 
rule: 
matching: colon [colon, :, 4]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E 
rule: 
matching: id [id, E, 4]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
rule: 
matching: semi [semi, ;, 4]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] public 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public 
rule: 
<visibility>: public [CREATE_LEAF: public] [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] [CREATE_LEAF: public] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public 
rule: 
matching: public [public, public, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberFuncDecl> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor 
rule: 
<memberDecl>: <memberFuncDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon constructor 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor 
rule: 
<memberFuncDecl>: constructor colon openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar [CREATE_NODE: memberConstructorDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar colon 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor 
rule: 
matching: constructor [constructor, constructor, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : 
rule: 
matching: colon [colon, :, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( 
rule: 
matching: openpar [openpar, (, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A 
rule: 
matching: id [id, A, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : 
rule: 
matching: colon [colon, :, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float 
rule: 
matching: float [float, float, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , 
rule: 
matching: comma [comma, ,, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B 
rule: 
matching: id [id, B, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : 
rule: 
matching: colon [colon, :, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] float 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float 
rule: 
<type>: float [CREATE_LEAF: float] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: float] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float 
rule: 
matching: float [float, float, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][epsilon][id][float][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] closepar [CREATE_NODE: fParams] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberConstructorDecl] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) 
rule: 
matching: closepar [closepar, ), 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][epsilon][visibility][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
rule: 
matching: semi [semi, ;, 5]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl][memberConstructorDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 6]
semantic stack: 
[epsilon][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
rule: 
matching: semi [semi, ;, 6]
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function 
rule: 
matching: function [function, function, 8]
semantic stack: 
[epsilon][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A 
rule: 
matching: id [id, A, 8]
semantic stack: 
[epsilon][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> scopeop 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: 
rule: 
<funcHeadFollowing>: scopeop <funcHeadFollowingFuncOrCons> 
semantic stack: 
[epsilon][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowingFuncOrCons> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: 
rule: 
matching: scopeop [scopeop, ::, 8]
semantic stack: 
[epsilon][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction 
rule: 
<funcHeadFollowingFuncOrCons>: id [CREATE_LEAF: id] openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: scopedFunctionHead] 
semantic stack: 
[epsilon][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction 
rule: 
matching: id [id, ifFunction, 8]
semantic stack: 
[epsilon][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( 
rule: 
matching: openpar [openpar, (, 8]
semantic stack: 
[epsilon][class][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][class][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> returntype 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) 
rule: 
matching: closepar [closepar, ), 8]
semantic stack: 
[epsilon][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] <returnType> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => 
rule: 
matching: returntype [returntype, =>, 8]
semantic stack: 
[epsilon][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] void 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: scopedFunctionHead] [CREATE_NODE: returnType] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
rule: 
matching: void [void, void, 8]
semantic stack: 
[epsilon][class][epsilon][id][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][scopedFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
rule: 
matching: opencubr [opencubr, {, 9]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar if 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if 
rule: 
<statement>: if openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: ifCondition] closepar then [EPSILON: epsilon] <statBlock> [CREATE_NODE: thenStatements] else [EPSILON: epsilon] <statBlock> [CREATE_NODE: elseStatements] [CREATE_NODE: ifStatement] semi 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if 
rule: 
matching: if [if, if, 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( 
rule: 
matching: openpar [openpar, (, 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a 
rule: 
matching: id [id, a, 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: lt] lt 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 
rule: 
<relOp>: lt [CREATE_LEAF: lt] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: lt] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 
rule: 
matching: lt [lt, <, 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr][lt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 
rule: 
matching: intnum [intnum, 1, 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) 
rule: 
matching: closepar [closepar, ), 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then 
rule: 
matching: then [then, then, 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> opencubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
rule: 
matching: opencubr [opencubr, {, 10]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} 
rule: 
matching: closecubr [closecubr, }, 11]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else 
rule: 
matching: else [else, else, 11]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> opencubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
rule: 
matching: opencubr [opencubr, {, 11]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> <statement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a 
rule: 
matching: id [id, a, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> openpar [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( 
rule: 
<idnestFollowing>: [EPSILON: epsilon] openpar <aParams> closepar [CREATE_NODE: aParams] [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( 
rule: 
matching: openpar [openpar, (, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b 
rule: 
matching: id [id, b, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) 
rule: 
matching: closepar [closepar, ), 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . 
rule: 
matching: dot [dot, ., 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c 
rule: 
matching: id [id, c, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 
rule: 
matching: intnum [intnum, 1, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e 
rule: 
matching: id [id, e, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = 
rule: 
matching: assign [assign, =, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a 
rule: 
matching: id [id, a, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 
rule: 
matching: intnum [intnum, 2, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 
rule: 
matching: intnum [intnum, 1, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . 
rule: 
matching: dot [dot, ., 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b 
rule: 
matching: id [id, b, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 
rule: 
matching: intnum [intnum, 3, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 
rule: 
matching: intnum [intnum, 4, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + 
rule: 
matching: plus [plus, +, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c 
rule: 
matching: id [id, c, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . 
rule: 
matching: dot [dot, ., 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d 
rule: 
matching: id [id, d, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 
rule: 
matching: intnum [intnum, 3, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 
rule: 
matching: opensqbr [opensqbr, [, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 
rule: 
matching: intnum [intnum, 5, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] 
rule: 
matching: closesqbr [closesqbr, ], 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . 
rule: 
matching: dot [dot, ., 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b 
rule: 
matching: id [id, b, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> openpar [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 
rule: 
<idnestFollowing>: [EPSILON: epsilon] openpar <aParams> closepar [CREATE_NODE: aParams] [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 
rule: 
matching: openpar [openpar, (, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 
rule: 
matching: intnum [intnum, 1, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) 
rule: 
matching: closepar [closepar, ), 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice][idIndice][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][epsilon][funcCall][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
rule: 
matching: semi [semi, ;, 12]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 13]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifCondition][thenStatements][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
rule: 
matching: semi [semi, ;, 13]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return 
rule: 
matching: return [return, return, 14]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 
rule: 
matching: openpar [openpar, (, 14]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 
rule: 
matching: intnum [intnum, 0, 14]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) 
rule: 
matching: closepar [closepar, ), 14]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
rule: 
matching: semi [semi, ;, 14]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 15]
semantic stack: 
[epsilon][class][scopedFunctionHead][epsilon][ifStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function 
rule: 
matching: function [function, function, 17]
semantic stack: 
[epsilon][class][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction 
rule: 
matching: id [id, whileFunction, 17]
semantic stack: 
[epsilon][class][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( 
rule: 
matching: openpar [openpar, (, 17]
semantic stack: 
[epsilon][class][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][class][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) 
rule: 
matching: closepar [closepar, ), 17]
semantic stack: 
[epsilon][class][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => 
rule: 
matching: returntype [returntype, =>, 17]
semantic stack: 
[epsilon][class][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: integer] integer 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][class][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: integer] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
rule: 
matching: integer [integer, integer, 17]
semantic stack: 
[epsilon][class][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
rule: 
matching: opencubr [opencubr, {, 18]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while 
rule: 
matching: while [while, while, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( 
rule: 
matching: openpar [openpar, (, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a 
rule: 
matching: id [id, a, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 
rule: 
matching: opensqbr [opensqbr, [, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 
rule: 
matching: intnum [intnum, 1, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . 
rule: 
matching: dot [dot, ., 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b 
rule: 
matching: id [id, b, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 
rule: 
matching: opensqbr [opensqbr, [, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 
rule: 
matching: intnum [intnum, 2, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] 
rule: 
matching: closesqbr [closesqbr, ], 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: or] or 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or 
rule: 
<addOp>: or [CREATE_LEAF: or] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: or] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or 
rule: 
matching: or [or, or, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term][or]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term][or][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c 
rule: 
matching: id [id, c, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term][or][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term][or][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term][or][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term][or][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][epsilon][term][or][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] lt 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < 
rule: 
<relOp>: lt [CREATE_LEAF: lt] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < 
rule: 
matching: lt [lt, <, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction 
rule: 
matching: id [id, ifFunction, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> openpar [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 
rule: 
<idnestFollowing>: [EPSILON: epsilon] openpar <aParams> closepar [CREATE_NODE: aParams] [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <aParams> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 
rule: 
matching: openpar [openpar, (, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> <expr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 
rule: 
matching: intnum [intnum, 1, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] closepar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] [CREATE_NODE: aParams] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) 
rule: 
matching: closepar [closepar, ), 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) 
rule: 
matching: closepar [closepar, ), 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
rule: 
matching: opencubr [opencubr, {, 19]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] openpar read 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read 
rule: 
<statement>: read openpar [EPSILON: epsilon] <variable> [CREATE_NODE: readStatement] closepar semi 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] openpar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read 
rule: 
matching: read [read, read, 20]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( 
rule: 
matching: openpar [openpar, (, 20]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi closepar [CREATE_NODE: readStatement] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d 
rule: 
<variable>: [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi closepar [CREATE_NODE: readStatement] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d 
rule: 
matching: id [id, d, 20]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi closepar [CREATE_NODE: readStatement] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi closepar [CREATE_NODE: readStatement] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) 
rule: 
matching: closepar [closepar, ), 20]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
rule: 
matching: semi [semi, ;, 20]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 21]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileCondition][epsilon][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
rule: 
matching: semi [semi, ;, 21]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return 
rule: 
matching: return [return, return, 22]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 
rule: 
matching: openpar [openpar, (, 22]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 
rule: 
matching: intnum [intnum, 1, 22]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) 
rule: 
matching: closepar [closepar, ), 22]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) ; 
rule: 
matching: semi [semi, ;, 22]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 23]
semantic stack: 
[epsilon][class][function][normalFunctionHead][epsilon][whileStatement][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> 
input: 
class A isa B , C , D , E { 
attribute c : integer ; 
private attribute b : float ; 
public attribute d : E ; 
public constructor : ( A : float , B : float ) ; 
} ; 
function A :: ifFunction ( ) => void 
{ 
if ( a < 1 ) then { 
} else { 
a ( b ) . c [ 1 ] [ e ] = a [ 2 ] [ 1 ] . b [ 3 ] [ 4 ] + c . d [ 3 ] [ 5 ] . b ( 1 ) ; 
} ; 
return ( 0 ) ; 
} 
function whileFunction ( ) => integer 
{ 
while ( a [ 1 ] . b [ 2 ] or c < ifFunction ( 1 ) ) { 
read ( d ) ; 
} ; 
return ( 1 ) ; 
} 
rule: 
<multiClassDeclOrFuncDef>: 
semantic stack: 
[program]
-----------------------------------------------------------------------
