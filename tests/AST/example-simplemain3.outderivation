stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class 
rule: 
<START>: [EPSILON: epsilon] <multiClassDeclOrFuncDef> [CREATE_NODE: program] 
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class 
rule: 
matching: class [class, class, 48]
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C 
rule: 
matching: id [id, C, 48]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
rule: 
<optClassDecl2>: 
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
rule: 
matching: opencubr [opencubr, {, 48]
semantic stack: 
[epsilon][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute 
rule: 
<visibility>: [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute 
rule: 
matching: attribute [attribute, attribute, 49]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a 
rule: 
matching: id [id, a, 49]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : 
rule: 
matching: colon [colon, :, 49]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer 
rule: 
matching: integer [integer, integer, 49]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][epsilon][visibility][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
rule: 
matching: semi [semi, ;, 49]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute 
rule: 
<visibility>: [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute 
rule: 
matching: attribute [attribute, attribute, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b 
rule: 
matching: id [id, b, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : 
rule: 
matching: colon [colon, :, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer 
rule: 
matching: integer [integer, integer, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
rule: 
matching: semi [semi, ;, 50]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<visibility>: [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
matching: attribute [attribute, attribute, 51]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c 
rule: 
matching: id [id, c, 51]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : 
rule: 
matching: colon [colon, :, 51]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer 
rule: 
matching: integer [integer, integer, 51]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
rule: 
matching: semi [semi, ;, 51]
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} 
rule: 
matching: closecubr [closecubr, }, 52]
semantic stack: 
[epsilon][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
rule: 
matching: semi [semi, ;, 52]
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
matching: function [function, function, 54]
semantic stack: 
[epsilon][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main 
rule: 
matching: id [id, main, 54]
semantic stack: 
[epsilon][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( 
rule: 
matching: openpar [openpar, (, 54]
semantic stack: 
[epsilon][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) 
rule: 
matching: closepar [closepar, ), 54]
semantic stack: 
[epsilon][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
rule: 
matching: returntype [returntype, =>, 54]
semantic stack: 
[epsilon][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void 
rule: 
matching: void [void, void, 55]
semantic stack: 
[epsilon][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][class][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
rule: 
matching: opencubr [opencubr, {, 55]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar 
rule: 
matching: localvar [localvar, localVar, 56]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m 
rule: 
matching: id [id, m, 56]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : 
rule: 
matching: colon [colon, :, 56]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C 
rule: 
matching: id [id, C, 56]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
rule: 
matching: semi [semi, ;, 56]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][epsilon][id][id][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar 
rule: 
matching: localvar [localvar, localVar, 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n 
rule: 
matching: id [id, n, 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : 
rule: 
matching: colon [colon, :, 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C 
rule: 
matching: id [id, C, 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySize> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 
rule: 
<multiArraySize>: <arraySize> <multiArraySize> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 
rule: 
<arraySize>: opensqbr [EPSILON: epsilon] <arraySizeParam> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 
rule: 
matching: opensqbr [opensqbr, [, 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 
rule: 
<arraySizeParam>: intnum [CREATE_LEAF: intNum] closesqbr [CREATE_NODE: arraySize] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 
rule: 
matching: intnum [intnum, 7, 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] 
rule: 
matching: closesqbr [closesqbr, ], 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][epsilon][intNum]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][epsilon][arraySize]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
rule: 
matching: semi [semi, ;, 57]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][id][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m 
rule: 
matching: id [id, m, 58]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . 
rule: 
matching: dot [dot, ., 58]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a 
rule: 
matching: id [id, a, 58]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 
rule: 
matching: assign [assign, =, 58]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 
rule: 
matching: intnum [intnum, 123, 58]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
rule: 
matching: semi [semi, ;, 58]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write 
rule: 
matching: write [write, write, 59]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( 
rule: 
matching: openpar [openpar, (, 59]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m 
rule: 
matching: id [id, m, 59]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] dot 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . 
rule: 
<multiIdnest>: dot [EPSILON: epsilon] id [CREATE_LEAF: id] <idnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . 
rule: 
matching: dot [dot, ., 59]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a 
rule: 
matching: id [id, a, 59]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) 
rule: 
matching: closepar [closepar, ), 59]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) ; 
rule: 
matching: semi [semi, ;, 59]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 60]
semantic stack: 
[epsilon][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localVar m : C ; 
localVar n : C [ 7 ] ; 
m . a = 123 ; 
write ( m . a ) ; 
} 
rule: 
<multiClassDeclOrFuncDef>: 
semantic stack: 
[program]
-----------------------------------------------------------------------
